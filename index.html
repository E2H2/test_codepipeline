<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Mini Tetris + Local Leaderboard</title>
  <style>
    :root{
      --bg:#0b1220; --panel:#0f172a; --line:#1e293b;
      --text:#e2e8f0; --muted:#94a3b8; --accent:#38bdf8;
      --radius:16px;
    }
    *{box-sizing:border-box}
    body{
      margin:0; min-height:100vh;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Apple SD Gothic Neo","Noto Sans KR", sans-serif;
      background: radial-gradient(1200px 700px at 20% 0%, #13213f 0%, var(--bg) 55%),
                  radial-gradient(900px 600px at 100% 0%, #1b2b4f 0%, var(--bg) 60%);
      color:var(--text);
      display:flex; align-items:center; justify-content:center;
      padding:24px;
    }
    .wrap{
      width:min(980px, 100%);
      display:grid;
      grid-template-columns: 1fr 340px;
      gap:16px;
    }
    @media (max-width: 900px){
      .wrap{ grid-template-columns: 1fr; }
    }
    .card{
      background: linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.02));
      border:1px solid rgba(148,163,184,.15);
      border-radius: var(--radius);
      box-shadow: 0 18px 55px rgba(0,0,0,.35);
      overflow:hidden;
    }
    .hd{
      padding:14px 16px;
      display:flex; align-items:center; justify-content:space-between; gap:12px;
      border-bottom:1px solid rgba(148,163,184,.12);
      background: rgba(15, 23, 42, .35);
      backdrop-filter: blur(8px);
    }
    .title{font-weight:800; letter-spacing:-.02em}
    .pill{
      font-size:12px; color:var(--muted);
      border:1px solid rgba(148,163,184,.2);
      padding:6px 10px; border-radius:999px;
      white-space:nowrap;
    }
    .main{
      padding:16px;
      display:flex;
      justify-content:center;
      align-items:flex-start;
      gap:16px;
      flex-wrap:wrap;
    }
    canvas{
      background: rgba(2, 6, 23, .7);
      border:1px solid rgba(148,163,184,.14);
      border-radius:14px;
      image-rendering: pixelated;
    }
    .side{
      padding:16px;
      display:grid;
      gap:12px;
    }
    .stat{
      display:flex; justify-content:space-between; gap:12px;
      padding:12px 12px;
      border:1px solid rgba(148,163,184,.14);
      border-radius:14px;
      background: rgba(2,6,23,.35);
      align-items:center;
    }
    .k{color:var(--muted); font-size:12px}
    .v{font-weight:800}
    .btns{display:flex; gap:10px; flex-wrap:wrap}
    button{
      cursor:pointer;
      border:1px solid rgba(148,163,184,.2);
      background: rgba(255,255,255,.04);
      color:var(--text);
      padding:10px 12px;
      border-radius:14px;
      font-weight:700;
    }
    button:hover{background: rgba(255,255,255,.07)}
    button.primary{
      border-color: rgba(56,189,248,.45);
      box-shadow: 0 0 0 4px rgba(56,189,248,.12) inset;
    }
    button.danger{
      border-color: rgba(251,113,133,.35);
      color: #fecdd3;
    }
    button.danger:hover{background: rgba(251,113,133,.08)}
    .hint{
      color:var(--muted); font-size:12px; line-height:1.55;
      padding:12px 12px;
      border:1px dashed rgba(148,163,184,.22);
      border-radius:14px;
      background: rgba(2,6,23,.25);
    }
    .rankWrap{
      display:block;
      padding:12px 12px;
      border:1px solid rgba(148,163,184,.14);
      border-radius:14px;
      background: rgba(2,6,23,.35);
    }
    .rankHead{
      display:flex; justify-content:space-between; align-items:center; gap:10px;
      margin-bottom:10px;
    }
    .rankList{
      margin:0; padding-left:18px;
      color:var(--text);
    }
    .rankList li{
      margin:6px 0;
      color: rgba(226,232,240,.92);
      font-size:12.5px;
      line-height:1.35;
    }
    .toast{
      position:fixed; left:50%; bottom:18px; transform:translateX(-50%);
      padding:10px 12px; border-radius:999px;
      border:1px solid rgba(148,163,184,.2);
      background: rgba(2,6,23,.72);
      color:var(--text);
      font-size:12px;
      opacity:0; pointer-events:none;
      transition: opacity .2s ease;
    }
    .toast.show{opacity:1}
  </style>
</head>

<body>
  <div class="wrap">
    <section class="card">
      <div class="hd">
        <div class="title">Mini Tetris</div>
        <div class="pill" id="statusPill">RUNNING</div>
      </div>

      <div class="main">
        <canvas id="game" width="360" height="720" aria-label="tetris"></canvas>
        <canvas id="next" width="160" height="160" aria-label="next piece"></canvas>
      </div>
    </section>

    <aside class="card">
      <div class="hd">
        <div class="title">Info</div>
        <div class="pill">Local leaderboard</div>
      </div>

      <div class="side">
        <div class="stat"><div class="k">Score</div><div class="v" id="score">0</div></div>
        <div class="stat"><div class="k">Lines</div><div class="v" id="lines">0</div></div>
        <div class="stat"><div class="k">Level</div><div class="v" id="level">1</div></div>

        <div class="btns">
          <button class="primary" id="btnPause">P : Pause</button>
          <button id="btnReset">R : Reset</button>
        </div>

        <div class="rankWrap">
          <div class="rankHead">
            <div class="k">Leaderboard (Top 10)</div>
            <button class="danger" id="btnClearRank" style="padding:6px 10px;border-radius:999px;">Clear</button>
          </div>
          <ol class="rankList" id="rankList"></ol>
          <div class="hint" id="rankHint" style="margin-top:10px">아직 기록이 없어요.</div>
        </div>

        <div class="hint">
          <b>조작</b><br/>
          ← → : 이동<br/>
          ↓ : 소프트 드랍<br/>
          ↑ : 회전<br/>
          Space : 하드 드랍<br/>
          P : 일시정지 / 재개<br/>
          R : 리셋
        </div>

        <div class="hint">
          <b>저장 방식</b><br/>
          랭킹은 이 브라우저의 localStorage에 저장돼요.<br/>
          (다른 기기/브라우저와 공유되지 않음)
        </div>
      </div>
    </aside>
  </div>

  <div class="toast" id="toast"></div>

<script>
(() => {
  // ===== Config =====
  const COLS = 10;
  const ROWS = 20;
  const BLOCK = 36;
  const NEXT_BLOCK = 32;

  const RANK_KEY = "mini-tetris-leaderboard-v1";

  // Color palette (piece id -> color)
  const COLORS = {
    0: "rgba(0,0,0,0)",
    I: "#22c55e",
    O: "#fbbf24",
    T: "#a78bfa",
    S: "#38bdf8",
    Z: "#fb7185",
    J: "#60a5fa",
    L: "#f97316",
    GHOST: "rgba(226,232,240,.18)"
  };

  // Tetromino shapes (4x4 matrices)
  const SHAPES = {
    I: [
      [0,0,0,0],
      [1,1,1,1],
      [0,0,0,0],
      [0,0,0,0],
    ],
    O: [
      [0,1,1,0],
      [0,1,1,0],
      [0,0,0,0],
      [0,0,0,0],
    ],
    T: [
      [0,1,0,0],
      [1,1,1,0],
      [0,0,0,0],
      [0,0,0,0],
    ],
    S: [
      [0,1,1,0],
      [1,1,0,0],
      [0,0,0,0],
      [0,0,0,0],
    ],
    Z: [
      [1,1,0,0],
      [0,1,1,0],
      [0,0,0,0],
      [0,0,0,0],
    ],
    J: [
      [1,0,0,0],
      [1,1,1,0],
      [0,0,0,0],
      [0,0,0,0],
    ],
    L: [
      [0,0,1,0],
      [1,1,1,0],
      [0,0,0,0],
      [0,0,0,0],
    ],
  };

  const PIECES = Object.keys(SHAPES);
  const randPieceType = () => PIECES[(Math.random() * PIECES.length) | 0];

  // ===== DOM =====
  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d");
  const nextCanvas = document.getElementById("next");
  const nctx = nextCanvas.getContext("2d");

  const $score = document.getElementById("score");
  const $lines = document.getElementById("lines");
  const $level = document.getElementById("level");
  const $status = document.getElementById("statusPill");
  const $toast = document.getElementById("toast");

  const $rankList = document.getElementById("rankList");
  const $rankHint = document.getElementById("rankHint");
  document.getElementById("btnClearRank").addEventListener("click", clearRanking);

  document.getElementById("btnPause").addEventListener("click", () => togglePause());
  document.getElementById("btnReset").addEventListener("click", () => reset());

  // ===== State =====
  let board, current, next, score, lines, level;
  let dropInterval, dropCounter, lastTime;
  let paused = false;
  let gameOver = false;
  let gameOverHandled = false;

  // ===== UI helpers =====
  function toast(msg){
    $toast.textContent = msg;
    $toast.classList.add("show");
    setTimeout(() => $toast.classList.remove("show"), 1100);
  }

  function updateHUD(){
    $score.textContent = String(score);
    $lines.textContent = String(lines);
    $level.textContent = String(level);
  }

  // ===== Leaderboard (localStorage) =====
  function loadRanking(){
    try{
      const raw = localStorage.getItem(RANK_KEY);
      return raw ? JSON.parse(raw) : [];
    }catch(e){
      return [];
    }
  }

  function saveRanking(list){
    localStorage.setItem(RANK_KEY, JSON.stringify(list));
  }

  function renderRanking(){
    const list = loadRanking();
    $rankList.innerHTML = "";

    if(!list.length){
      $rankHint.style.display = "block";
      return;
    }
    $rankHint.style.display = "none";

    for(const r of list){
      const li = document.createElement("li");
      const when = new Date(r.at).toLocaleDateString();
      li.textContent = `${r.name} — ${r.score}점 (L${r.level}, ${r.lines}줄) · ${when}`;
      $rankList.appendChild(li);
    }
  }

  function recordScore(){
    let name = prompt("게임 오버! 이름을 입력하면 랭킹에 저장돼요:", "Guest");
    if(name === null) return;
    name = name.trim() || "Guest";

    const entry = { name, score, lines, level, at: Date.now() };
    const list = loadRanking();
    list.push(entry);

    list.sort((a,b) => (b.score - a.score) || (b.at - a.at));
    saveRanking(list.slice(0, 10));
    renderRanking();
  }

  function clearRanking(){
    if(!confirm("랭킹 기록을 전부 지울까?")) return;
    localStorage.removeItem(RANK_KEY);
    renderRanking();
    toast("Ranking cleared");
  }

  // ===== Game helpers =====
  function makeBoard(){
    return Array.from({length: ROWS}, () => Array(COLS).fill(0));
  }

  function cloneMatrix(m){ return m.map(r => r.slice()); }

  function makePiece(type){
    return {
      type,
      m: cloneMatrix(SHAPES[type]),
      x: (COLS/2 | 0) - 2,
      y: -1
    };
  }

  function rotate(matrix, dir){
    const m = cloneMatrix(matrix);
    for(let y=0;y<m.length;y++){
      for(let x=0;x<y;x++){
        [m[x][y], m[y][x]] = [m[y][x], m[x][y]];
      }
    }
    if(dir > 0) m.forEach(row => row.reverse());
    else m.reverse();
    return m;
  }

  function collide(b, piece){
    const {x:px, y:py, m} = piece;
    for(let y=0;y<m.length;y++){
      for(let x=0;x<m[y].length;x++){
        if(!m[y][x]) continue;
        const bx = px + x;
        const by = py + y;
        if(bx < 0 || bx >= COLS || by >= ROWS) return true;
        if(by >= 0 && b[by][bx]) return true;
      }
    }
    return false;
  }

  function merge(b, piece){
    const {x:px, y:py, m, type} = piece;
    for(let y=0;y<m.length;y++){
      for(let x=0;x<m[y].length;x++){
        if(!m[y][x]) continue;
        const bx = px + x;
        const by = py + y;
        if(by >= 0) b[by][bx] = type;
      }
    }
  }

  function clearLines(){
    let cleared = 0;
    outer: for(let y=ROWS-1; y>=0; y--){
      for(let x=0; x<COLS; x++){
        if(!board[y][x]) continue outer;
      }
      // full row
      const row = board.splice(y, 1)[0];
      row.fill(0);
      board.unshift(row);
      cleared++;
      y++;
    }

    if(cleared > 0){
      const points = [0, 100, 300, 500, 800][cleared] || (cleared * 250);
      score += points * level;
      lines += cleared;

      const newLevel = 1 + Math.floor(lines / 10);
      if(newLevel !== level){
        level = newLevel;
        dropInterval = Math.max(90, 800 - (level-1)*70);
        toast(`Level ${level}`);
      }
      updateHUD();
    }
  }

  function spawn(){
    current = makePiece(next.type);
    next = { type: randPieceType(), m: cloneMatrix(SHAPES[randPieceType()]) };
    // fix next properly
    next.type = randPieceType();
    next.m = cloneMatrix(SHAPES[next.type]);

    if(collide(board, current)){
      gameOver = true;
      paused = false;
      $status.textContent = "GAME OVER";
      $status.style.color = "#fb7185";
      toast("Game Over — R로 리셋");

      if(!gameOverHandled){
        gameOverHandled = true;
        // 한 번만 기록
        recordScore();
      }
    }

    drawNext();
  }

  function lockPiece(){
    merge(board, current);
    clearLines();
    spawn();
  }

  function move(dir){
    if(gameOver || paused) return;
    const nx = current.x + dir;
    if(!collide(board, {...current, x: nx})) current.x = nx;
  }

  function tryRotate(dir){
    if(gameOver || paused) return;
    const rotated = rotate(current.m, dir);

    const kicks = [0, -1, 1, -2, 2];
    for(const k of kicks){
      const test = {...current, m: rotated, x: current.x + k};
      if(!collide(board, test)){
        current.m = rotated;
        current.x = current.x + k;
        return;
      }
    }
  }

  function hardDrop(){
    if(gameOver || paused) return;
    while(!collide(board, {...current, y: current.y+1})){
      current.y++;
      score += 1;
    }
    updateHUD();
    lockPiece();
  }

  function softDrop(){
    if(gameOver || paused) return;
    if(!collide(board, {...current, y: current.y+1})){
      current.y++;
      score += 1;
      updateHUD();
    } else {
      lockPiece();
    }
    dropCounter = 0;
  }

  function togglePause(){
    if(gameOver) return;
    paused = !paused;
    $status.textContent = paused ? "PAUSED" : "RUNNING";
    $status.style.color = paused ? "#fbbf24" : "";
    toast(paused ? "Paused" : "Resume");
  }

  // ===== Drawing =====
  function drawGrid(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.strokeStyle = "rgba(148,163,184,.08)";
    ctx.lineWidth = 1;
    for(let x=0; x<=COLS; x++){
      ctx.beginPath();
      ctx.moveTo(x*BLOCK, 0);
      ctx.lineTo(x*BLOCK, ROWS*BLOCK);
      ctx.stroke();
    }
    for(let y=0; y<=ROWS; y++){
      ctx.beginPath();
      ctx.moveTo(0, y*BLOCK);
      ctx.lineTo(COLS*BLOCK, y*BLOCK);
      ctx.stroke();
    }
  }

  function drawCell(c, x, y, size){
    if(!c) return;
    const pad = 1.2;
    const px = x*size;
    const py = y*size;

    ctx.fillStyle = COLORS[c] || "#e2e8f0";
    ctx.fillRect(px+pad, py+pad, size-2*pad, size-2*pad);

    ctx.fillStyle = "rgba(255,255,255,.10)";
    ctx.fillRect(px+pad, py+pad, size-2*pad, (size-2*pad)*0.35);

    ctx.strokeStyle = "rgba(15,23,42,.35)";
    ctx.lineWidth = 1;
    ctx.strokeRect(px+pad, py+pad, size-2*pad, size-2*pad);
  }

  function drawBoard(){
    for(let y=0; y<ROWS; y++){
      for(let x=0; x<COLS; x++){
        const c = board[y][x];
        if(c) drawCell(c, x, y, BLOCK);
      }
    }
  }

  function ghostY(){
    let gy = current.y;
    while(!collide(board, {...current, y: gy+1})) gy++;
    return gy;
  }

  function drawPiece(piece, size, drawGhost=false){
    const {x:px, y:py, m, type} = piece;

    if(drawGhost){
      const gy = ghostY();
      for(let y=0; y<m.length; y++){
        for(let x=0; x<m[y].length; x++){
          if(!m[y][x]) continue;
          const bx = px + x;
          const by = gy + y;
          if(by >= 0){
            ctx.fillStyle = COLORS.GHOST;
            ctx.fillRect(bx*size+2, by*size+2, size-4, size-4);
          }
        }
      }
    }

    for(let y=0; y<m.length; y++){
      for(let x=0; x<m[y].length; x++){
        if(!m[y][x]) continue;
        const bx = px + x;
        const by = py + y;
        if(by >= 0) drawCell(type, bx, by, size);
      }
    }
  }

  function drawNext(){
    nctx.clearRect(0,0,nextCanvas.width,nextCanvas.height);
    nctx.fillStyle = "rgba(2,6,23,.6)";
    nctx.fillRect(0,0,nextCanvas.width,nextCanvas.height);
    nctx.strokeStyle = "rgba(148,163,184,.14)";
    nctx.strokeRect(0.5,0.5,nextCanvas.width-1,nextCanvas.height-1);

    if(!next) return;
    const m = next.m;
    const type = next.type;

    const offsetX = 0.5;
    const offsetY = 0.8;

    for(let y=0; y<m.length; y++){
      for(let x=0; x<m[y].length; x++){
        if(!m[y][x]) continue;
        const px = (x+offsetX) * NEXT_BLOCK;
        const py = (y+offsetY) * NEXT_BLOCK;

        nctx.fillStyle = COLORS[type] || "#e2e8f0";
        nctx.fillRect(px+2, py+2, NEXT_BLOCK-4, NEXT_BLOCK-4);

        nctx.fillStyle = "rgba(255,255,255,.12)";
        nctx.fillRect(px+2, py+2, NEXT_BLOCK-4, (NEXT_BLOCK-4)*0.35);

        nctx.strokeStyle = "rgba(15,23,42,.35)";
        nctx.strokeRect(px+2, py+2, NEXT_BLOCK-4, NEXT_BLOCK-4);
      }
    }
  }

  function draw(){
    drawGrid();
    drawBoard();
    if(current) drawPiece(current, BLOCK, true);

    if(paused || gameOver){
      ctx.fillStyle = "rgba(2,6,23,.55)";
      ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle = "rgba(226,232,240,.92)";
      ctx.font = "800 28px ui-sans-serif, system-ui";
      ctx.textAlign = "center";
      ctx.fillText(gameOver ? "GAME OVER" : "PAUSED", canvas.width/2, canvas.height/2 - 10);
      ctx.fillStyle = "rgba(148,163,184,.9)";
      ctx.font = "600 14px ui-sans-serif, system-ui";
      ctx.fillText(gameOver ? "Press R to reset" : "Press P to resume", canvas.width/2, canvas.height/2 + 20);
    }
  }

  // ===== Loop =====
  function update(time=0){
    const delta = time - lastTime;
    lastTime = time;

    if(!paused && !gameOver){
      dropCounter += delta;
      if(dropCounter > dropInterval){
        softDrop();
      }
    }

    draw();
    requestAnimationFrame(update);
  }

  // ===== Input =====
  window.addEventListener("keydown", (e) => {
    if(["ArrowLeft","ArrowRight","ArrowDown","ArrowUp","Space"].includes(e.code)) e.preventDefault();

    if(e.code === "KeyP"){ togglePause(); return; }
    if(e.code === "KeyR"){ reset(); return; }

    if(gameOver || paused) return;

    if(e.code === "ArrowLeft") move(-1);
    else if(e.code === "ArrowRight") move(1);
    else if(e.code === "ArrowDown") softDrop();
    else if(e.code === "ArrowUp") tryRotate(1);
    else if(e.code === "Space") hardDrop();
  });

  // ===== Reset =====
  function reset(){
    board = makeBoard();
    score = 0;
    lines = 0;
    level = 1;
    dropInterval = 800;
    dropCounter = 0;
    lastTime = 0;
    paused = false;
    gameOver = false;
    gameOverHandled = false;

    $status.textContent = "RUNNING";
    $status.style.color = "";

    updateHUD();

    // init next & spawn
    next = { type: randPieceType(), m: cloneMatrix(SHAPES[randPieceType()]) };
    next.type = randPieceType();
    next.m = cloneMatrix(SHAPES[next.type]);

    renderRanking();
    spawn();
    toast("Reset!");
  }

  // Start
  reset();
  update();
})();
</script>
</body>
</html>
